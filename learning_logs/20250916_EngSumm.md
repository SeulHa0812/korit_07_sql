## Aggregate Functions

### Common Functions
1. **COUNT()** – counts the number of **rows**  
2. **AVG()** – returns the average val**ue  
3. **SUM()** – returns the sum  
4. **MIN()** – returns the minimum value  
5. **MAX()** – returns the maximum value  

- These 5 functions are widely supported across most RDBMSs, though some functions may differ slightly by DB type.

## Scalar (Single-Row) Functions
 Functions that process or transform data on a **row-by-row basis**.

### Common Functions
1. **ROUND()**  
   - Rounds a numeric value to the specified number of decimal places.  
   - Syntax: `ROUND(column, decimals)`  

2. **SUBSTR()**  
   - Returns part of a string, starting from a given position with a specified length.  
   - Syntax: `SUBSTR(column, start, length)`  

3. **LENGTH()**  
   - Returns the length of a string.  
   - Syntax: `LENGTH(column)`  
   - *(Some DBMSs use `LEN()` instead of `LENGTH()`)*  

4. **UPPER()**  
   - Converts alphabetic characters to uppercase.  
   - Syntax: `UPPER(column)`  

5. **LOWER()**  
   - Converts alphabetic characters to lowercase.  
   - Syntax: `LOWER(column)`  

---

### Key Difference from Aggregate Functions
- **Aggregate functions**: combine **multiple rows** into a **single result**.  
- **Scalar functions**: operate on **each row** and return a **result per row**.  

---
### COUNT()

```sql
-- Count all rows in users
SELECT COUNT(*) FROM users;

-- Count non-NULL values in country column
SELECT COUNT(country) FROM users;
```
- `COUNT()` ignores NULL values.

### COUNT(DISTINCT   )
```sql
-- Count distinct countries (no duplicates)
SELECT COUNT(DISTINCT country) FROM users;
```
---
### MIN(), MAX(), SUM()
```sql
-- Get min and max price from products
SELECT MIN(price) FROM products;
SELECT MAX(price) FROM products;
SELECT SUM(price) FROM products;
```
---
### AVG(), ROUND(value, decimals) 
→ rounds the result to the specified number of decimal places.
```sql
-- Average discount price
SELECT AVG(discount_price) FROM products;

-- Round average discount price to 2 decimals
SELECT ROUND(AVG(discount_price), 2) FROM products;

-- With alias
SELECT ROUND(AVG(discount_price), 2) AS avgPrice FROM products;
```
---
### String & Date Functions (useful with aggregation)

### SUBSTR(column, start, length) 
→ extracts part of a string.
```sql
-- Extract day (YYYY-MM-DD) and month (YYYY-MM) from created_at
SELECT SUBSTR(created_at, 1, 10) AS day,
       SUBSTR(created_at, 1, 7)  AS month,
       created_at
  FROM users;
```
Note: unlike Java/Python/JS, index starts at 1, and length is inclusive.  

Always check the original column (e.g., SELECT created_at) before applying.

### LENGTH()
```sql
-- Get length of username
SELECT LENGTH(username), username FROM users;
```
Some DBMSs use LEN() instead of LENGTH().

---
### Usage Notes
- Aggregate functions can only be used in the `SELECT` clause (with optional `GROUP BY`).  
- Scalar functions can be used in **SELECT** as well as in **WHERE** clauses.  

**Example**:
```sql
-- Using scalar function in WHERE
SELECT * FROM users 
 WHERE LENGTH(username) <= 10;
```
## GROUP BY
-> "How should we group the data for calculation?"
- Aggregate functions alone are not always enough.  
- Often, we need to calculate metrics **by categories** (e.g., user count by country, monthly signups).  
- `GROUP BY` groups rows based on one or more columns, and then aggregate functions are applied to each group.

Example

```sql
-- Count distinct users in Korea
SELECT COUNT(DISTINCT id) AS uniqueUserCnt
FROM users
WHERE country = 'Korea';

-- Problem: only gives Korea. To know counts for all countries, we need GROUP BY.

-- Count users grouped by country
SELECT country, COUNT(DISTINCT id) 
FROM users
GROUP BY country;
```
Multiple Conditions
```sql
-- Count users by country and marketing consent
SELECT country, is_marketing_agree, COUNT(DISTINCT id) AS uniqueUserCnt
FROM users
GROUP BY country, is_marketing_agree
ORDER BY country ASC, is_marketing_agree DESC;
```
- When using multiple columns in GROUP BY, the order matters.
- First group by country, then within each country, group by is_marketing_agree.
- **Output: each country will appear twice (one row with is_marketing_agree=1, one row with 0).**

Nested Grouping Example
```sql
-- Users grouped by country and city
SELECT country, city, COUNT(DISTINCT id) AS userCnt
FROM users
GROUP BY country, city
ORDER BY country ASC, userCnt DESC;
```
- **Dimension**: grouping basis (e.g., country, city).
- **Metric**: the calculation applied (e.g., COUNT(DISTINCT id)).

Monthly Signups Example
```sql
-- Count users by month (latest first)
SELECT SUBSTR(created_at, 1, 7) AS month, COUNT(DISTINCT id) AS userCnt
FROM users
GROUP BY month
ORDER BY month DESC;
```
- SUBSTR(created_at, 1, 7) extracts YYYY-MM.
- Aliases (AS month) can also be used in GROUP BY (depends on DB).
---
### GROUP BY Summary
- Use GROUP BY when you need to compute metrics per group, not for the whole table.
- Multiple grouping criteria can be specified with commas (,).
- Order defines the grouping hierarchy.
- Always include grouping columns in the SELECT clause for clarity.

Example:
```sql
-- Not clear
SELECT COUNT(id) FROM users GROUP BY country, city;

-- Clear (dimension + metric)
SELECT country, city, COUNT(id) AS userCnt
FROM users
GROUP BY country, city;
```
Convention: list dimensions first, then metrics (improves readability in practice).

## HAVING
- Filters **aggregated results** after `GROUP BY`.
- We often group data (e.g., user count by country, monthly signups) and then need to filter **by the aggregated values** (e.g., “countries with ≥ N users”).

Why HAVING?
- `WHERE` filters **raw rows** before grouping.
- Aggregates (like `COUNT()`, `SUM()`) are computed **after** `GROUP BY`, so you **cannot** use them in `WHERE`.
- Use `HAVING` to filter **on aggregate results**.

---
Example: user counts for selected countries
```sql
SELECT country, COUNT(DISTINCT id)
FROM users
WHERE country IN ('Korea', 'USA', 'France')
GROUP BY country;
```
If you want only countries with ≥ 8 users without checking first, use HAVING:
```sql
-- Using the aggregate in HAVING
SELECT country, COUNT(DISTINCT id) AS userCnt
FROM users
GROUP BY country
HAVING COUNT(DISTINCT id) > 7
ORDER BY userCnt DESC;  -- same as ORDER BY 2 DESC
```
Example: per-staff order metrics with HAVING
From orders, compute order count and distinct ordering users per staff_id.  
Return rows where order_cnt ≥ 10 and user_cnt ≤ 40, sorted by order_cnt desc.
```sql
SELECT
  staff_id,
  COUNT(id)                AS order_cnt,
  COUNT(DISTINCT user_id)  AS user_cnt
FROM orders
GROUP BY staff_id
HAVING order_cnt >= 10 AND user_cnt <= 40
ORDER BY order_cnt DESC;
```
Note: In many DBs (incl. MySQL/MariaDB), you can reference column aliases (order_cnt, user_cnt) inside HAVING. If your DB doesn’t allow it, use the full aggregates again.

---
### HAVING vs WHERE (Key Points)

WHERE: filters rows before grouping; cannot use aggregates here.

HAVING: filters after grouping; can use aggregate expressions (COUNT(), SUM(), …).

---
### Logical Processing Order (simplified)
```sql
SELECT        # 5
  FROM        # 1
  WHERE       # 2 
  GROUP BY    # 3
  HAVING      # 4
  ORDER BY    # 6
```
1. Load source rows (FROM)
2. Filter raw rows (WHERE)
3. Form groups (GROUP BY)
4. Filter groups by aggregates (HAVING)
5. Project columns / compute expressions (SELECT)
6. Sort result (ORDER BY)

### Conventions & Notes

Convention: Put dimensions first (grouping keys), then metrics (aggregates) in SELECT for readability.

Note: In HAVING, every column you reference should either be:
- part of the GROUP BY, or
- an aggregate expression (e.g., COUNT(*), SUM(price)).



# CUD 관련 수업
1. Datadase 생성
```sql
create database 데이터베이스명

CREATE DATABASE kor_it
```
2. 특정 DB의 사용
```sql
use 데이터베이스명

USE kor_it
```
3. 테이블 생성
```sql
create table 테이블명(
  컬럼1 속성1, 속성2, ...,
  컬럼2 속성a, 속성b, ...,
);

CREATE TABLE students (
  student_id INT AUTO_INCREMENT PRIMARY KEY,
  student_name VARCHAR(100) NOT NULL,
  enrollment_date DATE NOT NULL
);
```
students에는 없고 students2에는 있는 컬럼 email. 이미 생성된 테이블에 대고 컬럼 추가해야함.

- 컬럼 추가 SQL문
```sql
ALTER TABLE 테이블명 ADD COLUMN 컬럼명 자료형 조건;

ALTER TABLE students ADD COLUMN student_email VARCHAR(100) NOT NULL;
```

- 컬럼 삭제 SQL문
```sql
ALTER TABLE 테이블명 DROP COLUMN 컬럼명;
ALTER TABLE students DROP COLUMN email;
```

- 해당 칼럼의 모든 데이터가 영구적으로 삭제. 되돌릴 수 없기 때문에 백업 등 사전 준비 필요.

- 컬럼 수정 SQL문
1. CHANGE : 기존 컬럼의 컬럼명 및 자료형과 조건을 전부 새로 세팅할 때 사용.
```sql
ALTER TABLE 테이블명 CHANGE COLUMN 기존컬럼명 새컬럼명 자료형, 조건
```
CHANGE를 쓸 경우 컬럼명만 바꾸더라도 자료형과 조건을 전부 다 명시해줘야 함.
```sql
ALTER TABLE students2 CHANGE COLUMN email students2_email VARCHAR(100) NOT NULL;
```

2. RENAME : 컬럼의 이름만 변경하고 기존 자료형과 조건은 유지됨. DB에 따라 지원이 되는 것도 있고 아닌 것도 있음.
```sql
ALTER TABLE students2 RENAME COLUMN 기존컬럼명 TO 새컬럼명;

ALTER TABLE students2 RENAME COLUMN email TO students2_email;
```

enrollment_date 삭제하고, 다시 student_enrollment_date를 추가

student_id / student_name /student_email / student_enrollment_date 순서

```sql
ALTER TABLE students DROP COLUMN enrollment_date;

ALTER TABLE students ADD COLUMN student_enrollment_date VARCHAR(100) NOT NULL;
```
DB 생성 / DB 사용 / 테이블 생성 / 컬럼 추가 / 컬럼 수정 / 컬럼 삭제와 관련된 DDL

DATA(row) 추가 / 수정 / 삭제 DML
---
- students 테이블에 데이터 삽입 SQL문
```sql
INSERT INTO 테이블명 (컬럼명1, 컬럼명2, ..., 컬럼명n) VALUES (데이터a1, 데이터a2, ..., 데이터an), (데이터b1, 데이터b2, ..., 데이터bn)

insert INTO students (student_name, student_email, student_enrollment_date) VALUES 
('김 일', 'kim1@test.com', '2025-09-18'),
('김이', 'kim2@test.com', '2025-01-01');
```
이상의 코드에서 주목해야 하는 부분은 student_id 컬럼에 값을 insert하지 않았다는 점. 이유는 저희가 TABLE 생성 시(즉, DDL을 사용했을 때), AUTO INCREMENT를 적용했기 때문

그리고 전체 컬럼에 차례대로 데이터를 입력한다고 가정하면 (컬럼명1, 컬럼명2, ..., 컬럼명n) 부분이 없어도 됨. 다만 실무 상에서는 어느 컬럼에 어떤 데이터를 넣었는지 명확하게 하기 위해 항상 명시해 주는 편.

- 특정 데이터 수정 SQL문
```sql
UPDATE 테이블명
SET 컬럼명 = 바꿀데이터값
WHERE 컬럼명 = 검생가능한데이터값

UPDATE students
SET student_name = '김사백오십'
WHERE student_id = 1;
```

- 특정 데이터 삭제 SQL문
```sql
DELETE FROM 테이블명
WHERE 조건;
```

지시 사항

1. data 추가
```sql
INSERT INTO students (student_name, student_email, student_enrollment_date) VALUES ('김삼', 'kim3@test.com', '2025-02-01'), ('김사', 'kim4@test.com', '2025-03-01');
```

2. data 삭제
```sql
DELETE FROM students
WHERE student_id = 3;
```

3. data 수정
```sql
UPDATE students
SET student_enrollment_date = '2025-04-04'
WHERE student_id = 4;
```

4. select 이용 김사 데이터만 출력
```sql
SELECT *
FROM students
WHERE student_name = '김사';
```

지시 사항 - 
1. 다음을 만족하는 테이블을 생성하시오 (sql ver.)
테이블명 : instructor
컬럼명 :
  1. instructor_id / INT / PK / auto increment
  2. name / varchar(100) / not null
  3. email / varchar(100) / not null
  4. hire_date / DATE / not null
```sql
CREATE TABLE instructor (
  instructor_id INT AUTO_INCREMENT PRIMARY KEY,
  name varchar(100) not null,
  email varchar(100) not null,
  hire_date DATE not null
);
```
2. info 추가
```sql
INSERT INTO instructor (name, email, hire_date) VALUES ('이일', '21@test.com', '2025-09-18'), ('이이', '22@test.com', '2025-09-18'), ('이삼', '23@test.com', '2025-09-18');
```

3. 과목 테이블 courses 생성
```sql
CREATE TABLE courses (
  course_id INT AUTO_INCREMENT PRIMARY KEY,
  course_name VARCHAR(100) NOT NULL,
  instructor_id INT NOT NULL,
  start_date DATE NOT NULL,
  end_date DATE NOT NULL,
  FOREIGN KEY (instructor_id) REFERENCES instructor(instructor_id)
);
```
students / cources간의 관계 테이블 하나 만들 것.
테이블명 : student_courses

student_id / INT / PK,FK
course_id / INT / PK,FK

- student_id 와 course_id의 값을 조합하여 _복합 기본 키(Composite Primary Key)_ 로 설정할 것.
- 일반 PK 처럼 테이블의 각 행이 고유하도록 보장하며, 같은 수강생이 동일한 과목이 중복해서 등록할 수가 없게 됌.
예를 들어 student_id = 1인 학생이 course_id = 2에 해당하는 python 과목을 수강한다고 가정했을 때의 student_courses 테이블의 pk는 12가 될 것.
추후 1 학생이 다시 2를 들으려고 하면 pk가 12로 중복될 것이기 때문에 고유값을 침해하여 수강 불가가 뜨게 될 것.

출석 현황 테이블 생성(attendence)
tablename : attendence
attendence_id / int / pk
student_id / int / fk
course_id / int / fk
date / DATE
status / varchar(10) / 예시 출석, 결석 etc

```sql
CREATE TABLE attendence (
  attendence_id INT AUTO_INCREMENT PRIMARY KEY,
  student_id INT NOT NULL,
  course_id INT NOT NULL,
  date DATE NOT NULL,
  status VARCHAR(10) NOT NULL,
  FOREIGN KEY (student_id) REFERENCES students(student_id),
  FOREIGN KEY (course_id) REFERENCES courses(course_id)
);
```

예제 데이터 삽입
```sql
-- attendence
INSERT INTO attendence (student_id, course_id, date, status) VALUES
(1, 1, '2025-09-18', '출'),
(2, 1, '2025-09-18', '결'),
(4, 1, '2025-09-18', '출'),
(1, 2, '2025-09-19', '출'),
(2, 2, '2025-09-19', '출'),
(4, 2, '2025-09-19', '결');

-- courses
INSERT INTO courses (course_name, instructor_id, start_date, end_date) VALUES
('Java', 1, '2025=09-01', '2025-09-30'),
('Python', 2, '2025=09-02', '2025-09-29');

-- instructor
INSERT INTO instructor (name, email, hire_date) VALUES 
('김선생', 'kimt@test.com', '2025-07-01'),
('이선생', 'leet@test.com', '2025-01-01');

-- studnet_courses
INSERT INTO student_courses (student_id, course_id) VALUES
(1, 1),
(2, 1),
(4, 1),
(1, 2),
(4, 2);
```
지시 사항 1

수강생 목록 및 과목 조회
students / student_courses / courses
테이블을 결합하여, 각 학생의 이름과 그 학생이 수강하는 모든 과목명을 조회하도록 할 것. 결과는 이름 순.
```sql
SELECT s.student_name, c.course_name
  FROM students s
  INNER JOIN student_courses sc ON s.student_id = sc.student_id
  INNER JOIN courses c ON sc.course_id = c.course_id
  ORDER BY s.student_name;
```

2. 김사백오십 학생의 이름과 이메일 그리고 수강 과목을 출력하시오.
```sql
SELECT s.student_name, s.student_email, c.course_name
  FROM students s
  INNER JOIN student_courses sc ON s.student_id = sc.student_id
  INNER JOIN courses c ON sc.course_id = c.course_id
  WHERE s.student_name = '김사백오십'
```

3. 이일 강사의 교수 과목과 수강생 수 출력.
```sql
SELECT i.name, c.course_name, COUNT(DISTINCT sc.student_id) AS studentCnt
  FROM instructor i
  INNER JOIN courses c ON i.instructor_id = c.instructor_id
  INNER JOIN student_courses sc ON c.course_id = sc.course_id
  WHERE i.instructor_id = 1
  GROUP BY c.course_name;
```

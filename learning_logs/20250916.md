## 데이터를 계산하는 함수
- Excel에서 합계를 구하고, 평균을 계산하고, 개수를 세는 것과 같은 작업을 하는 것처럼 SQL에서도 동일한 작업이 가능함(그리고 비슷하게 생김). 문자열을 원하는 만큼 잘라내거나, 대/소문자를 변경하는 등의 함수로 나뉨.
  1. 집계 함수 : 합 / 평균 / 개수 세기 etc
  2. 일반 함수 : 문자열 slicing / 대소문자 변경 etc

### 그룹별로 집계 함수를 적용하기 위해 데이터를 나누는 GROUP BY
- 전체 데이터에 함수를 적용하기도 하지만, 그룹별로 수치를 도출하는 경우도 많음. 이상의 경우에는 GROUP BY를 이용해 데이터를 그룹으로 묶은 후 필요한 함수를 적용하는 방식 사용.
  - '국가별 회원 수를 집계해라.'
  - '일별 매출을 계산해라.'  
등의 그룹화 기준을 지정하여 계산 수행.

### GROUP BY로 계산한 결과를 다시 필터링하는 HAVING
- GROUP BY는 말그대로 그룹화하는 경우를 말함. 이상에서 언급한 '국가별 회원 수를 집계'하는 것까지만 가능함. 하지만 거기에 더해서 '국가별 회원 수를 계산하고, 회원 수가 10 명 이상인 국가만 추출'하는 등의 추가적인 조건을 걸기 위해서는 _그룹화 이후에 조건을 설정_ 해야 함. 즉, _집계 함수로 계산한 결과 중에서 조건에 맞는 데이터_ 를 걸어야 함.

- 이상에서 중요한 것은 WHERE은 table 자체에 걸리는 조건이기 때문에 집계 함수 이전에 사용이 불가능하다는 점.

### 집계 함수
1. COUNT() - 행(row)의 개수를 계산
2. AVG() - 평균
3. SUM() - 합

- 예제
```sql
SELECT COUNT(*) FROM users;
      - 모든 행의 개수 계산 후 보여달라
SELECT COUNT(country) FROM users;
      - country column의 데이터의 개수를 계산 후 보여달라
```
NULL 체크 여부 때문에 저희 기준으로 77 나오는데 결과값은 76 되어야 정상임.

- COUNT() 함수는 주어진 컬럼의 값이 null이 아닌 행의 개수 반환.

2. 예제 : 회원 정보 테이블 users에서 존재하는 국가(country)를 세는 SQL문(중복 제외).
```sql
SELECT COUNT(DISTINCT country) FROM users;
```
- DISTINCT : 중복을 제외한 결과값을 COUNT할 때 사용.

3. 예제 : 제품 정보 테이블 products에서 최저가,최고가,합계를 출력(정상 가격 기준으로).
```sql
SELECT MIN(price) FROM products;
SELECT MAX(price) FROM products;
SELECT SUM(price) FROM products;
```

6. 예제 : products에서 discount_price 기준으로 평균
```sql
SELECT AVG(discount_price) FROM products;
```
결과값이 너무 길어 달러화 기준이니 소수점 둘째자리 까지만 표기하기 위해 함수 사용.
```sql
SELECT ROUND(AVG(discount_price), 2) FROM products;
SELECT ROUND(AVG(discount_price), 2) AS avgPrice FROM products;
```
- ROUND(데이터, 결과값소수점자리) : 결과값을 소수점표기자리까지만 나타내도록 반올림하는 함수

7. 예제 : users에서 가입일(day/가입연월일출력) / 가입연월(month/가입연월출력) / 가입일시(created_at/시간까지 출력)
```sql
SELECT SUBSTR(created_at, 1, 10) AS day, 
       SUBSTR(created_at, 1, 7) AS month, 
       created_at 
       FROM users
       ;
```
- SUBSTR(컬럼명, 시작점, 종료점) : 컬럼명에서의 시작점을 기준으로 종료값까지의 데이터를 잘라내서 return
  - 주의 사항 : Java / Python / JS에서의 index 개념과 달리 1부터 시작하며, 종료점이 미안이 아니라 _이하_ 에 해당함.
- 결과적으로 SUBSTR()을 사용하기 위해서는 원본 데이터를 볼 수 있어야 하므로 SELECT created_at FROM users; 를 확인 후에 SUBSTR()을 적용해야 할 필요성이 있겠음.

- LENGTH() : DB에 따라서 LEN()이라고 쓰기도 함
8. 예제 : users에서 이메일 문자열의 길이 추출
```sql
SELECT LENGTH(username), username FROM users;
```
### 집계 함수 요약
1. SUM() / 합계 / SUM(컬럼명)
2. AVG() / 평균 / AVG(컬럼명)
3. MIN() / 최소값 / MIN(컬럼명)
4. MAX() / 최대값 / MAX(컬럼명)
5. COUNT() / 개수 / COUNT(컬럼명)

이상의 5 개는 DB 종류가 달라도 거의 동일하긴 한데, 일부 함수는 DB마다 지원 여부가 다름

### 일반 함수 요약 : 데이터를 가공하거나 변형
1. ROUND()
  - 소수점 자리를 저장한 자리수까지 반올림하여 반환 / ROUND(컬럼명, 소수점자리수)
2. SUBSTR()
  - 문자열을 지정한 시작 위치로부터 지정한 문자 개수만큼 가져와 반환 / SUBSTR(컬럼명, 시작점, 문자개수)
3. LENGTH()
  - 문자열의 길이를 반환 / LENGTH(컬럼명)
4. UPPER()
  - 알파벳 문자열을 대문자로 변경하여 반환 / UPPER(컬럼명)
5. LOWER()
  - 알파벳 문자열을 소문자로 변경하여 반환 / LOWER(컬럼명)

- 집계 함수는 _여러 행의 데이터를 하나의 결과값_ 으로 집계하는 반면, 일반 함수는 _한 행의 데이터에 하나의 결과값을 반환_ 한다는 차이점이 있음.

- 이상의 차이 때문에 집계 함수는 _SELECT에서만 사용 가능_ 하지만 일반 함수는 SELECT 뿐만 아니라 WHERE절에서도 사용 가능.

## 연습 문제
1. products에서 정상 가격을 모두 더한 값을 구하시오.
```sql
SELECT SUM(price) FROM products;
```
2. products에서 id가 30 이하인 제품의 정상 가격의 평균을 구하시고(단, 소수점 둘째자리까지 표기)
```sql
SELECT ROUND(AVG(price), 2) FROM products WHERE id <= 30;
```
3. users에서 가입일시가 2010-10 부터 2010-12까지인 회원 아이디를 중복 없이 센(count) 값 출력
```sql
SELECT COUNT(DISTINCT id) FROM users WHERE SUBSTR(created_at, 1, 7) BETWEEN '2010-10' AND '2010-12';
```
4. users에서 이메일(username)의 길이가 17 자리 이하인 회원 수를 중복 없이 센(count)값 출력
```sql
SELECT COUNT(DISTINCT id) FROM users WHERE LENGTH(username) <= 17;
```

## GROUP BY
### 어떤 기준으로 묶어서 '계산'할까?
- 집계함수만으로 원하는 결과를 얻을 수 없을 때가 있음. 데이터 전체가 아니라 원하는 기준으로 그룹을 나눠 계산할 일이 있기 때문에. 예를 들어서 전체 회원 수가 아닌 국가별 회원 수를 나누어 계산하기도 하며, 월별로 가입한 회원 수를 집계하기도 함.

예제 - users에서 country가 Korea인 회원의 수 출력
```sql
SELECT COUNT(DISTINCT id) AS uniqueUserCnt FROM users WHERE country = 'Korea';
```
이상의 경우에는 한국에 해당하는 숫자만 알 수 있으니까, 미국 따로 일본 따로 브라질 따로 일일이 해야 하는가, 하는 문제 발생. - 즉, 국가별 회원 수를 전부 알고 싶다면 이상의 쿼리에서 country = '' 부분을 여러 개 작성해야한다는 결론이 나옴.

실제 환경에서는 더 많은 데이터를 다루는 만큼, WHERE 절의 조건을 하나하나 바꾸는 방식은 잘 쓰이지 않음.
이때 도입되는 것이 GROUP BY임.

예제 : users에서 국가별 회원 수를 추출
```sql
SELECT country, COUNT(DISTINCT id) FROM users
  GROUP BY country;
```
GROUP BY는 집계 함수와 함께 사용되며, GROUP BY 기준 컬럼은 SELECT에서 집계 함수를 사용할 때 묶어서 계산을 수행하는 _기준_ 이 됨. 그룹으로 나뉜 결과에 따라 집계 함수가 적용되어 결과 출력.

즉 이상의 SQL문은 'country'의 데이터들을 기준으로 그룹화하라고 했기 때문에 아르헨티나 / 오스트리아 / 벨기에 ... 등으로 country의 각 값들이 일치하는 것들을 기준으로 집계 함수가 개별적으로 적용되었다고 볼 수 있음.

예제 : users에서 country가 Korea인 회원 중 마케팅 수신 동의한 회원 수를 추출하시오.
```sql
SELECT id FROM users WHERE country = 'Korea' AND is_marketing_agree = 1;
```
이상의 경우는 두 가지 조건을 동시에 적용하여 필터링하고, 집계 함수로 원하는 지표를 추출함.

- 한국 대신 독일에 사는 회원의 마케팅 수신 동의 건수를 확인하려면?
- 한국에 살고 있기는 하지만 마케팅 수신 동의를 하지 않은 회원 수를 확인하려면?

당연히 WHERE절 값 바꿔주는 것도 가능
하지만 많은 조건을 걸어야 할 때마다 직접 쿼리를 바꾼다면 시간도 많이 들고 데이터가 누락될 수도 있음.

GROUP BY를 활용했을 때, 두 가지 조건을 모두 충족하는 쿼리를 좀 더 쉽게 작성할 수 있음.

예제 : users에서 country 별로 마케팅 수신 동의를 한 회원 수 / 동의하지 않은 회원 수를 동시 추출
```sql
SELECT country, is_marketing_agree, COUNT(DISTINCT id) as uniqueUserCnt FROM users 
GROUP BY country, is_marketing_agree
GROUP BY country ASC, is_marketing_agree DESC;
```
ASC -> default

GROUP BY에 두 개 이상의 기준 컬럼을 추가하면 데이터가 여러 그룹으로 나뉨. 결과 화면 상에서 Argentina가 입력된 row가 두 개라는 점에 주목
<img src='./image.png'>
하나는 Argentina이면서 is_marketing_agree = 1인 row의 개수(회원 수 ) / 다른 하나는 Argentina이면서 is_marketing_agree = 0인 row의 개수를 뜻함.

이번 예시에서는 country로 먼저 그룹화가 이루어짐.
그 다음, is_marketing_agree를 기준으로 두 번째 그룹화가 다시 이루어짐.

- 이상으로 알 수 있는 중요한 점은 GROUP BY 다음에 복수의 그룹화 조건을 건다면, 그 순서 역시도 매우 중요 -> 지정된 컬럼의 순서에 따라 결과가 달라짐.

- 앞서 등장한 기준으로 한 번 그룹화가 이루어지고, 그 그룹 _내에서_ 그 다음 기준으로 그룹화가 _다시_ 이루어짐.

예제 : users에서 국가 내 도시별 회원 수를 추출(국가명은 알파벳순으로 정렬하고, 같은 국가 내에서는 회원 수 기준 내림차순으로 정렬할 것)
```sql
SELECT country, city, COUNT(DISTINCT id) AS userCnt FROM users 
  GROUP BY country, city
  ORDER BY country ASC, userCnt DESC;
```

- 차원(dimension) : 분석 시에 지표를 그룹으로 묶는 기준
- 매트릭(metric) : 각 차원에 대한 연산을 수행할 때 적용하는 계산식

이상의 쿼리문에서 차원은 country / city에 해당하고, metric은 COUNT(DISTINCT id)에 해당함.

예제 : users에서 월별 가입 회원수를 추출. created_at을 활용, 최신순으로 정렬
```sql
SELECT SUBSTR(created_at, 1, 7) AS month, COUNT(DISTINCT id) AS userCnt from users
  GROUP BY SUBSTR(created_at, 1, 7)
  ORDER BY month DESC;
```
도 가능하고,
```sql
SELECT SUBSTR(created_at, 1, 7) AS month, COUNT(DISTINCT id) AS userCnt from users
  GROUP BY month
  ORDER BY month DESC;
```
도 가능. 함수의 결과값을 기준으로 하는 것도 가능하고, AS를 통해서 새로 이름 지은 컬럼명으로도 가능(DB에 따라서 다름)

차원 -> 연월
메트릭 -> 회원수

### GROUP BY 요약
1. GROUP BY는 그룹별로 수치를 계산할 때 사용. 쉼표(,)를 써서 그룹화 기준을 복수로 지정 가능.
  - 두 개 이상의 기준을 지정할 때 컬럼 순서에 다라 그룹의 층위가 정해지므로 순서를 명확하게 지정해야 함.

*참조 : GROUP BY를 쓸 때에는 GROUP BY에 적은 컬럼을 기준으로 SELECT에도 동일한 순서로 적어 계산된 수치의 기준을 알려주면 시인성이 좀 더 좋음. 예를 들어 국가 내 도시별 회원 수를 구했는데, 회원 수 컬럼만 출력하면 각 숫자가 어느 국가, 어느 도시의 회원 수인지 알 수 없으므로, 국가와 도시 컬럼도 명확하게 쓰는 것.
```sql
SELECT COUNT(id) AS userCnt FROM users GROUP BY county, city;
```
라고 가정하면 컬럼 하나짜리 테이블리 출력. 그럼 그냥 1, 2, 5, 76, ... 로 숫자들만 있는 상황이 될테니까 쿼리를 직접 읽어보지 않는 이상 이게 어느 국가의 어느 도시의 호ㅓㅣ원 수인지 알지 못함.
```sql
SELECET 컬럼1, 컬럼2, ...
  GROUP BY 컬럼1, 컬럼2, ...
```
그래서 이상의 정리본을 도입하면
```sql
SELECT country, city, COUNT(id) AS userCnt FROM users 
  GROUP BY county, city;
```

* 참조 2 : 그리고 기존에 있는 컬럼들을 먼저 써주고, 그것에 대한 연산을 뒤에 서주게 된다면, 차원 / 메트릭이 서로 분리가 됨.
차원1, 차원2, 연산1, 연산2 같은 순서로요. 실무적으로 봤을 대 데이터 영역이 나뉘기 때문에 좀 더 시인성이 좋음.

연습 문제
1. orderdetails에서 주문 아이디 별 주문 수량의 총합을 출력할 것(주문 수량의 총합이 내림 차순으로)
```sql
SELECT order_id, SUM(quantity) AS OrderCntSum FROM orderdetails
  GROUP BY order_id
  ORDER BY OrderCntSum DESC;
```
2. orders에서 직원 아이디 별, 회원 아이디 별로 주문 건수를 출력할 것(단, 직원 아이디 기준 오름 차순으로 먼저 정렬한 뒤, 주문 건수 기준 내림 차순으로 정렬할 것).
```sql
SELECT user_id, staff_id, COUNT(*) AS cnt FROM orders
  GROUP BY user_id, staff_id
  ORDER BY staff_id ASC, cnt DESC;
```
3. orders에서 월별로 주문한 회원 수를 출력할 것(주문일자(order_date) 컬럼을 활용하고, 최신 순으로 정렬할 것).
```sql
SELECT SUBSTR(order_date, 1, 7) AS month, COUNT(DISTINCT user_id) AS user_count FROM orders 
  GROUP BY month
  ORDER BY month DESC;
```

## HAVING
- 집계 값을 다시 필터링하는 HAVING
- 이전까지의 수업에서 GROUP BY를 이용하여 데이터를 그룹화하고, 해당 그룹별로 집계 함수를 사용하여 연산 수행. 이 방법으로 국가별 회원 수를 추출하는 작업 수행.

- 그렇다면 여기서 추가적으로 국가별 회원 수가 n 명 이상인 국가의 회원수만 보기 위해서는, 
  1. 먼저 집계 함수를 도입하기 위해 SELECT 절에는 집계 함수를 사용할 것이고, 
  2. 조건이 아니라 GROUPING을 진행해야 할 것.
  3. 그래서 GROUPING의 결과값에 조건을 걸 필요가 있음.

예제 : users에서 country가 Korea / USA / France인 회원 수를 국가별로 출력
```sql
SELECT country, COUNT(DISTINCT id) FROM users
  WHERE country IN ('Korea', 'USA', 'France')
  GROUP BY country;
```
France = 9 / Korea = 8 / USA = 11 이라는 결과값 나옴.

3개국에 해당하는 국가ㅏ의 회원 수 말고, 회원 수가 8명 이상인 국가의 회원 수를 미리 확인하지 않고 바로 SQL문으로 해결하는 방법 기준
SELECT country, COUNT(DISTINCT id) FROM users
  WHERE COUNT(DISTINCT id) > 7 
  GROUP BY country;

일단 일반적으로 생각할 수 있는 방식이 WHERE이 조건절이니까 집계 함수의 결과값이 7 초과면 되지 않을까, 라고 생각했다면 현재까지 잘 배운 상태.

그런데 집계 함수는 어디에만 쓸 수 있다? -> SELECT절
그래서 invaild use of function 이라는 alert가 뜸.

근데 HAVING에서는 집계함수 결과값이 사용 가능함.
그래서 정답은
```sql
SELECT county, COUNT(DINSTINCT id) AS userCnt FROM users
  GROUP BY country
  HAVING COUNT(DISTINCT id) > 7
  ORDER BY 2 DESC;
```
* WHERE 절에서 필터링할 때 에러가 난 이유 :
  - 실행하는 쿼리의 순서와 관계있음.
  - WHERE의 경우 GROUP BY보다 먼저 실행되며, 컴퓨터가 그룹화를 하기 이전에 조건을 검토하는데, 집계함수로 계산된 값은 GROUP BY 실행 후에 계산되기 때문에 순서상의 오류가 나옴.

  - 정확한 순서에 관련한 부분은 HAVING 전체 정리 부분에서 도입할 예정

예제 : orders에서 담당 직원별(staff_id) 주문 건수와 주문 회원 수를 계산,
주문 건수가 10건 이상'이면서' 주문 회원 수가 40명 이하인 데이터만 출력.
(주문 건수 기준으로 내림차순 정렬)
```sql
SELECT staff_id, COUNT(id) AS order_cnt, COUNT(DISTINCT user_id) AS user_cnt FROM orders
  GROUP BY staff_id
  HAVING order_cnt >= 10 AND user_cnt <= 40
  ORDER BY order_cnt DESC;
```
직원 아이디별로 담당 주문 건수와 주문한 회원 수가 결과값으로 출력되었는데, 주문 건수는 10건 이상 / 회원 수는 40명 이하인 row만 표시됌. HAVING에서는 WHERE과 마찬가지로 AND / OR 연산자를 사용하여 다수의 조건을 병렬 위치 시킬 수 있음.

### HAVING 요약
- HAVING은 GROUP BY와 집계 함수를 이용해서 그룹별로 집계한 값을 필터링할 때 사용.
1. HAVING은 WHERE처럼 필터링 기능을 수행하지만, 적용 영역이 서로 다르다. _WHERE은 FROM에서 불러온 데이터를 직접 필터링_ 하지만 HAVING은 _GROUP BY가 실행된 이후의 집계 함수 값을 필터링_ 한다. 따라서 HAVING은 GROUP BY가 SELECT 문 내에 없다면 사용 자체가 불가능하다.

2. HAVING은 조건 연산자로 여러 조건문을 연결할 수 있으며, 연산이 적용되지 않은 기본 컬럼은 HAVING에서 사용할 수 없다.

3. 쿼리문의 실행 순서
```sql
SELECT        # 5
  FROM        # 1
  WHERE       # 2 
  GROUP BY    # 3
  HAVING      # 4
  ORDER BY    # 6
```
1. FROM을 읽어서 해당 테이블이 존재하는지, 존재한다면 그 테이블을 확인하는 작업을 실행.
2. WHERE 절을 실행하여 가져올 데이터의 범위를 확인.
3. GROUP BY를 통해서 DB에서 가져올 범위가 결정된 데이터에 대해 집계 연산을 적용할 수 있도록 데이터를 분할함.
4. HAVING을 통해 직전의 단계에서 그룹화 되어진 데이터(집계연산이후)를 가지고 조건을 적용하여 데이터를 필터링함.
5. SELECT가 실행되면서 필터링 범위가 그룹이 정해진 데이터에서 어떤 컬럼을 가지고 올지, 어떤 연산을 적용하여 값을 생성할지 결정.
6. ORDER BY를 통해 제시/생성된 컬럼을 기준으로 어떤 방식으로 데이터를 나열할지 결정.

연습 문제
1. orders에서 회원별 주문 건수를 추출할 것(단, 주문 건수가 7건 이상인 회원의 정보만 추출하고, 주문 건수 기준으로 내림 차순 정렬. user_id, id 컬럼 사용)
```sql
SELECT user_id, COUNT(id) AS orderCnt FROM orders 
  GROUP BY user_id
  HAVING orderCnt >= 7
  ORDER BY orderCnt DESC;
```
2. users에서 국가별 도시 수와 국가별 회원(id) 수 추출
(단, 도시 수 5 개 이상이고 회원 수 3명 이상 정보만 추출 / 도시 수, 회원 수 기준으로 모두 내림 차순 정렬)
```sql
SELECT country, COUNT(DISTINCT city) AS cityCnt, COUNT(id) AS idCnt FROM users
  GROUP BY country
  HAVING cityCnt >= 5 AND  idCnt >= 3
  ORDER BY cityCnt DESC, idCnt DESC;
```
3. users에서 이하의 국가(country)에 거주 중인 회원(id) 수를 국가별로 추출할 것(단, 회원 수가 5명 이상인 국가만 추출, 회원 수 기준으로 내림 차순 정렬)
USA / Brazil / Korea / Argentina / Mexico
```sql
SELECT country, COUNT(id) AS idCnt FROM users
  WHERE country IN ('USA', 'Brazil', 'Korea', 'Argentina', 'Mexico')
  GROUP BY country
  HAVING idCnt >= 5
  ORDER BY idCnt DESC;
```

# 여러 가지 데이터를 원하는대로 합치는 JOIN / UNION
- JOIN : 테이블을 좌우로 결합
- UNION : 테이블을 상하로 결합

SQL에서 데이터를 다루다보면 여러 테이블에 나뉘어 있는 데이터를 하나로 모아서 봐야 하는 경우가 생김. 즉, 테이블들을 미리 다 찢어놨다는 것을 의미. 특정 정보를 보기 위해서 다양한 테이블을 합치는 과정 필요, 이를 다 분할해둔 이유는 관계형 데이터베이스에서는 데이터의 중복을 피하고 쉽게 관리하기 위해서 데이터를 여러 곳에 나누어 보관함.

- 이상의 원칙을 _정규화(Data Nomalization)_ 이라고 함. 1 - 6 정규화까지 있긴 한데 실무에서는 약 3 정규화 정도 까지만 구현함을 원칙으로 함. 

## JOIN
주문 정보 테이블인 orders와 직원 정보 테이블 staff를 합친다고 가정. 두 테이블을 합칠 때에는 공통된 부분이 있어야 함. JOIN은 두 테이블의 컬럼 구성이 달라도 결합이 가능하며, _합친 테이블의 컬럼 수는 늘어남._

같은 테이블끼리의 JOIN을 수행하더라도 선택하는 JOIN 유형에 따라 다른 결과값이 나오게 됨. 그런데, 뭐가 됐든 결합을 위한 공통 분모인 key가 존재하고, 이것이 어제 배운 PK / FK 에 해당함.

## UNION
얘는 칼럼의 구성이 같은 두 쿼리 결과 집합을 상하로 결합함. 그래서 _결과는 결합 전의 컬럼 구성과 같음._ 그렇기때문에 결합 대상인 두 쿼리의 결과 집합은 컬럼 순서와 개수가 같아야 함.

# SubQuery
데이터가 저장된 상태 그대로 쿼리를 수행하기도 하지만, 쿼리를 수행한 결과를 값이나 조건으로 하여 다시 쿼리를 수행하는 경우도 있음. 즉, 쿼리 속의 쿼리를 사용하는데, 이를 서브쿼리라고 함. 그러면 여태까지 저희가 사용했던 SQL문에 다시 조건으로 활용되어 새로운 쿼리에 적용될 수도 있음.

## JOIN
### 컬럼 목록이 다른 테이블을 좌우로 결합
- 여태까지는 테이블 하나를 기준으로 데이터를 다루는 연습을 했지만, 지금부터는 복수의 테이블에서 필요한 정보들을 취합하여 출력할 예정.

- 국가별로 주문 건수를 알아보고 싶다면 어떻게해야할지
  - 국가 정보는 users 테이블에 있고, 주문 건수는 orders 테이블에 있으므로 users / orders를 동시에 다룰 필요가 있을 것.

- 집합의 결합 조건을 연상하면 좀 더 편하게 될 수 있는데, 얘가 일단 SQLD의 key 문제가 되는 경우가 많음.

### 예제 실습
회원 정보 테이블 users와 주문 정보 테이블 orders를 하나로 결합하여 출력(단, 주문 정보가 있는 정보만 출력할 것)
```sql
SELECT *
  FROM users u INNER JOIN orders o ON u.id = o.user_id;
  ORDER BY u.id DESC;
```
이상의 쿼리문을 실행했을 때 users 테이블과 orders 테이블의 정보가 모두 출력됨.
FROM까지는 동일해보이는데, users 다음에 앞으로 users 테이블의 특정 정보를 편하게 불러오기 위해 테이블 별칭을 u로 정했다는 부분을 확인할 수 있음.
그리고 JOIN 유형을 INNER JOIN으로 선택하고, 합쳐질 테이블인 orders 역시 추후 공통된 부분과의 연산을 위하여 o 라는 별칭을 지정함. 
다음 '주문 정보가 있는 회원만 출력'하기 위해 ON 조건으로 두 테이블 간의 교집합을 해주었음. 
1로 시작되지 않음을 확인했을 때, users 테이블의 id 컬럼의 값이 1인 row는 존재하지만, orders 테이블의 user_id 컬럼에는 1의 값을 지니는 row가 없기 때문에 최종 출력 결과에서 누락되었음을 알 수 있음.

AS는 컬럼명 지을 때만 사용

(축약어를 안정해도 무방. 근데 선호되는 작성 방식은 아님)

그러면 축약어 정했다고 했을 때는 u.id는 마치 객체명.필드명 처럼 우리가 값을 확인할 수 있음.

정리하자면, 두 테이블을 하나로 결합하려면 두 테이블에 공통된 부분이 존재해야 함. 관계형 데이터베이스에서는 이 부분을 키(key)라고 함. 그래서 관계형 데이터베이스에서는 키 값이 테이블에 반드시 한 개 이상 존재하도록 설계되어있고, 테이블에서 개별 행을 '유일하게 구분'지음.(id의 정의).
따라서 _키 값은 컬럼 내에서 중복되지 않으며 다른 개별 행을 구분해야 하므로 null 값을 가질 수도 없음._

- 참조 : 키 값은 테이블 내에서 고유한 값을 가지므로 한 테이블에서 개수를 계산할 때 중복되지 않음. 그런데 여러 테이블을 조인하면 키 값도 중복될 수 있음. 예를 들어서 회원 아이디가 7인 사람이 세 번 주문 했다면, 회원 정보와 주문 정보를 결합한(JOIN의 결과값) 테이블에서는 회원 아이디가 7인 row가 3개 있을 것임. 이때 '한 번이라도 주문한 회원 수'를 중복없이 구하려면 결국에는 DISTINCT 요구됨. 'COUNT(DISTINCT u.id)'의 형태로 작성해야 함.

users에 있는 id는 PK에 해당하고, orders에 있는 user_id는 FK에 해당함. 즉, PK와 FK의 결합을 통해서 JOIN이 이루어진다고 볼 수 있음.

그러면 논리적으로, FK의 중복 여부? 중복 가능

### INNER JOIN
- 두 테이블의 키 값이 _일치하는 행만_ 가져오는 JOIN. -> 집합의 개념으로 보자면 _교집합_ 에 해당함.

- u.id가 1인 정보가 o.user_id에 없었기 때문에 누락됨.

### LEFT JOIN
예제 : users와 orders를 하나로 결합하여 출력할 것(주문 정보가 _없는_ 회원의 정보도 출력할 것).

```sql
SELECT *
  FROM users u
    LEFT JOIN orders o
    ON u.id == o.user_id
  ORDER BY u.id;
```
OUTER는 생략 가능
```sql
SELECT *
  FROM users u
    LEFT OUTER JOIN orders o
    ON u.id == o.user_id
  ORDER BY u.id;
```
INNER JOIN과 유사하게 테이블 두 개가 합쳐지기는 했음. INNER JOIN이 두 개의 집합에서의 교집합 부분만 추출하는 반면에, LEFT JOIN의 경우는 먼저 언급된(users) 테이블의 전체 정보는 전부 다 출력하고, 그 중에서 orders 테이블과 일치하는 것들만 따로 더 가지고 오는 형태라고 할 수 있음.

얘네 두 개가 실무에서 제일 자주 쓰임. 데이터를 결합하는 경우 대부분 한쪽 테이블의 값을 보전해야 하는 경우가 많은데, LEFT (OUTER) JOIN이 이에 해당함.

하지만 주문 내역만 명확하게 보고 싶다면 INNER JOIN 쓸 것.

형식 :
FROM 테이블1 a (LEFT/INNER) JOIN 테이블2 b ON a.PK = b.FK;
LEFT : 왼쪽 테이블의 키 값이 오른쪽 테이블의 키 값과 _매칭되지 않는 행도_ 가지고 오는데, 왼쪽 테이블이 컬럼 값은 전부 다 출력하고, 오른쪽 테이블 컬럼 값은 null로 표기됨.
INNER : 오른쪽 왼쪽 테이블에서 전부 정보 조회가 되는 값들만 출력함.

```sql
SELECT u.id, u.created_at, u.username, o.id, o.oder_date, o.staff_id FROM users u LEFT JOIN orders o ON u.id = o.user_id ORDER BY u.id;
```

예제 : users와 orders를 하나로 합치는데, 주문 정보가 없는 회원의 정보만 출력할 것
```sql
SELECT *
  FROM users u 
    LEFT JOIN orders o ON u.id = o.user_id 
    ORDER BY u.id;
```
이상의 결과값은 주문정보가 있는/없는 회원 전부 추출됨
여기서 주문 정보가 없는 애들만 걸러야함
```sql
SELECT *
  FROM users u 
    LEFT JOIN orders o ON u.id = o.user_id
    WHERE o.id IS null 
    ORDER BY u.id;
```
이상에서 처음 배우는 개념 IS
프로그래밍 언어에서 배웠을 때는 == null을 위주로 썼을 때 == 에 해당한다고 봐도됨.

연습 문제 :
users와 orders 테이블을 하나로 결합하고, 추가로 orderdetails에 있는 데이터도 출력할 것(단, 주문 정보가 없는 회원의 주문 정보도 전부 출력하고, 다음 컬럼을 출력할 것.
회원 아이디 / 이메일 / 연락처 / 주문 아이디 / 제품 아이디)
```sql
SELECT u.id, u.username, u.phone, o.id, od.product_id
  FROM users u
  LEFT JOIN orders o
  ON u.id = o.user_id
  LEFT JOIN orderdetails od
  ON o.id = od.order_id;
ORDER BY u.id;
```
2중 JOIN 수행.
이상헤서 중요한 것은 기본적으로 SELECT * FROM users / orders / orderdetails를 수행해서 특정 테이블의 어느 컬럼이 다른 테이블의 컬럼과 일치하는지 여부를 찾을 일.
users 테이블은 기준이 됨.
그리고 orders 테이블에는 user_id 컬럼이 있음.
근데 orderdetails 테이블에는 order_id가 있음.
그러면 그 결과 users + orders 테이블 연산을 할때는 user의 id를 나타내는 u.id와 o.user_id를 공통점으로 JOIN 연산을 수행하고, 그 연산 결과를 기준으로 공통적으로 존재하는 order 테이블의 id를 나타내는 o.id 와  od.order_id를 공통점으로 JOIN 연산을 한 번 더 수행하는 것이라고 볼 수 있음.
